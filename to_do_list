1.  MVC MODEL, View Controller
    model: Resource in the app. Ex: User Post Atricle Stock...
    View: Front end. Ex: home new friends profile...
    Controller: like brain and backend. ex User_contorller

2.  rails new project名稱
    rails server
    config -> routes.rb 網址路徑。類似django的urls.py
    輸入 root 'application#hello' (controller檔案名稱#檔案中def名稱)
    這代表當傳進來的網址是root時，解析並且啟動 app -> Controllers -> application_controller 
    (以後可能會有不同的files 但是在routes.rb只要取前面的名稱就好 _controller不用加)
    進入到controller一開始沒東西，一開始先自己加上個 def hello

3.  app -> Controllers -> application_controller.rb 
    render html: 'xxx'  傳回一個html檔案。但通常會有個放template的資料夾 app -> views -> layouts

4.  現在建立一個新的controller
    project -> rails generate controller xxxx
    這樣就在app -> controllers中建立檔案
    也會在app -> views中建立資料夾放template，template的名稱通常是 xxx.html.erb

5.  structure
    * app -> assets 
        存放static file 像是image, stylesheets (css files), application.css (把這邊的css 連結到 views中)
        在views- > layouts -> application.html.erb中 <%= stylesheets_link_tag 'application', ...%>
        就是連結到 application.css
        同理。<%= javacript_pack_tag 'application', ...%>，就是連結到javascript中的application

    * app -> contorller 
        在controller.rb中常常看到 xxx < ApplicationController，這代表xxx由後者繼承所以不用把基本的功能重新定義，可以直接用
        contorller.rb中要自行定義action給routes.rb來連結

    * app -> helpers
        views templates中會用到

    * app -> views -> layouts -> application.html.erb
        因為有 <%= yield %> 可以讓不同hemplate都可以連結正確

    * bin 

    *config
    *congig -> routes.rb
    
    
6.  about page
    當我們要到某個網址，其實就是sent request (code指令上為get，因為要get到使用者傳遞的網址)
    config -> routes get 'about', to: 'pages#about' (get到網址，傳遞到page的app中做about的動作，to: 'contorller_name#action')
    因此也要在controller -> pages_controller 中加上 def about (因為是傳到pages這個controller中做about動作)
    另外到views -> pages 中建立template (about.html.erb)

    題外話：vscode中讓.erb檔案直接可以方便寫html的方法。去設定搜尋 emmet
    includeLanguage的setting.json 加入 "emmet.includeLanguages": {"*.erb": "html", "ruby": "html"}


7.  setup database
    ex: articel table裏面有 id title description user_id
    id: rails 自己會創立，user_id 使用者自行建立的
    常用的指令 Create Update Read Delete
    rails中用 ORM (Object Relational Mapper) (在ruby中又稱為 ActiveRecord )連結rail application code 跟 database，所以不用sql指令用ruby code
    從rails中的ActiveRecord 轉換到SQL資料庫，都在model層中處理

8.  用rails 提供的 scaffold創立 article database
    rails generate scaffold Xxxx(resource to generate，在本次範例是Article)
    rails generate scaffold Articel title:string description:text
    這時在db -> migrate資料夾中已經自動建立rb檔案
    按下 rails db:migrate 創立資料庫
    article_controller, article_nodel, 都有scaffold預設的內容

    routes中可以看到加上了一行 resources :articles
    用rails routes 檢視
    可以知道這個功能是直接連結到article_controller去接觸所有功能
    而不是之前接觸單一controller的單一action

9.  更加了解 table, migration article的功能與code (不經過scaffold)
    Ⅰ.  先建立table articles (database)
        rails generate migration create_articles (名稱可以自己設定)

    Ⅱ.  前往db中的migration.rb檔案
        因為名稱取的是CreateArticles，rails夠聰明知道我們要建立的是article
        加入 t.string :title
        t.text :description

        做了更新要migrate db rails db:migrate

        但是只有輸入這樣只會在一開始的時候建立，後續不能直接更新
        有兩種方式 1. rollback  2. 建立新的migration
        第1種砍掉重練很不推薦。尤其是多人合作時
        第2種方式。建立新的migration再把新的的行列放進去

        rails generate migration add_timestamps_to_articles
        add_column為內建方法，新增列到已經存在的table中
        add_column :table名稱(本案例中是article), 
                   :要新增的attribute名稱(在本案例中只能用created_at與updated_at，這樣rails才會幫我們自動追蹤), 
                   :data資料型態(本案例中是datetime),
 










xx. deploy to heroku
    本地的測試資料庫不會轉移。
    安裝heroku
    heroku login
    heroku create Xxx 建立檔案位址與網址。
    打開gem檔案，通常不會用sqlite3作為正式上線資料庫，而是用postgres，因此在gem檔案中新增
    group :production do
        gem: 'pg'
    end
    把 gem: 'sqlite3'從廣域的設定移動到 group :develope, :test do 中
    改動過gem所以要重新bundle install，更新gem lock
    bundle install --without production  
    這是避免破壞掉本地端的設定，因為在本地端Rail.env 是設定在 "development"，所以用的還是sqlite3，只有到heroku上才會用postgres
    git add .
    git commit -m "xxx"
    git push heroku master
    heroku open -> 開啟網頁
    heroku remane xxx -> repo改名，也會改變網址

